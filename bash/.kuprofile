## ls ## {{{
alias ls='ls -hF --color=auto'
alias ll='ls -lh'
alias lr='ls -R'                    # recursive ls
alias la='ll -A'
alias lx='ll -BX'                   # sort by extension
alias lz='ll -rS'                   # sort by size
alias lt='ll -rt'                   # sort by date
alias lm='la | more'
# }}}

e()
{
  if [[ $# -gt 0 ]] ; then
    nautilus $1 > /dev/null 2>&1 &
    return 0
  fi
  nautilus ./ > /dev/null 2>&1 &
}

pathadd()
{
  if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="${PATH:+"$PATH:"}$1"
  fi
}

# start-sshagent() {
#   eval "$(ssh-agent -s)"
#   ssh-add ~/.ssh/id_rsa
# }

prompt() {
  local __result=$1
  if [ $prompt -eq 0 ]; then
    local rc='y'
    eval $__result="'$rc'"
    return
  fi
  read -p "Proceed? [yNq] " -n 1 -r
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo ""
    echo -e "\e[36m>yes<\e[0m"
    echo ""
    local rc='y'
    eval $__result="'$rc'"
    return
  fi
  if [[ $REPLY =~ ^[Qq]$ ]]; then
    echo ""
    echo -e "\e[36m>quit<\e[0m"
    echo ""
    local rc='q'
    eval $__result="'$rc'"
    return
  fi
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    echo ""
    echo -e "\e[36m>no<\e[0m"
    echo ""
    local rc='n'
    eval $__result="'$rc'"
    return
  fi
  echo -e "\e[36m>no<\e[0m"
  local rc='n'
  eval $__result="'$rc'"
}

st() {

  usage() {
    echo ""
    echo "Performs 'git status' on all subfolders that are valid git repositories."
    echo ""
    echo "  st [options]"
    echo ""
    echo "Options:"
    echo "   -h, -?  Show this help."
    echo "   -p      Indicates whether to prompt before each action for each git repository."
    echo ""
  }

  prompt=0
  local OPTIND
  while getopts "h?p" opt; do
    case "$opt" in
      p)
        prompt=1
        ;;
      h|\?)
        usage
        return
        ;;
    esac
  done
  shift $((OPTIND-1))

  basedir=`eval pwd`
  basedirLength=${#basedir}

  if ! test -d "$basedir"; then
    echo "Folder does not exist"
    return
  fi

  if test -d "$basedir/.git"; then
    prompt result
    if [ "$result" == y ]; then
      git status
    fi
    return
  fi

  pushd "$basedir" &> /dev/null
  for dir in "$basedir"/*; do
    if test -d "$dir/.git"; then
      echo ""
      echo -e "\e[36m PROCESSING \e[30;48;5;43m ${dir:$basedirLength} \e[0m"
      prompt result
      if [ "$result" == q ]; then
        popd &> /dev/null
        return
      fi
      if [ "$result" == y ]; then
        cd "$dir"
        git status
      fi
    fi
  done
  echo ""
  popd &> /dev/null
}

cl() {

  usage() {
    echo ""
    echo "Performs 'git clean -x -d -f' on all subfolders that are valid git repositories."
    echo ""
    echo "  cl [options]"
    echo ""
    echo "Options:"
    echo "   -h, -?  Show this help."
    echo "   -p      Indicates whether to prompt before each action for each git repository."
    echo ""
  }

  prompt=0
  local OPTIND
  while getopts "h?p" opt; do
    case "$opt" in
      p)
        prompt=1
        ;;
      h|\?)
        usage
        return
        ;;
    esac
  done
  shift $((OPTIND-1))

  basedir=`eval pwd`
  basedirLength=${#basedir}

  if ! test -d "$basedir"; then
    echo "Folder does not exist"
    return
  fi

  if test -d "$basedir/.git"; then
    prompt result
    if [ "$result" == y ]; then
      git clean -x -d -f
    fi
    return
  fi

  pushd "$basedir" &> /dev/null
  for dir in "$basedir"/*; do
    if test -d "$dir/.git"; then
      echo ""
      echo -e "\e[36m PROCESSING \e[30;48;5;43m ${dir:$basedirLength} \e[0m"
      prompt result
      if [ "$result" == q ]; then
        popd &> /dev/null
        return
      fi
      if [ "$result" == y ]; then
        cd "$dir"
        git clean -x -d -f
      fi
    fi
  done
  echo ""
  popd &> /dev/null
}

pull() {

  usage() {
    echo ""
    echo "Performs 'git pull' on all subfolders that are valid git repositories."
    echo ""
    echo "  pull [options]"
    echo ""
    echo "Options:"
    echo "   -h, -?  Show this help."
    echo "   -p      Indicates whether to prompt after each action for each git repository."
    echo ""
  }

  prompt=0
  local OPTIND
  while getopts "h?p" opt; do
    case "$opt" in
      p)
        prompt=1
        ;;
      h|\?)
        usage
        return
        ;;
    esac
  done
  shift $((OPTIND-1))

  basedir=`eval pwd`
  basedirLength=${#basedir}

  if ! test -d "$basedir"; then
    echo "Folder does not exist"
    return
  fi

  if test -d "$basedir/.git"; then
    prompt result
    if [ "$result" == y ]; then
      git pull
    fi
    return
  fi

  pushd "$basedir" &> /dev/null
  for dir in "$basedir"/*; do
    if test -d "$dir/.git"; then
      echo ""
      echo -e "\e[36m PROCESSING \e[30;48;5;43m ${dir:$basedirLength} \e[0m"
      prompt result
      if [ "$result" == q ]; then
        popd &> /dev/null
        return
      fi
      if [ "$result" == y ]; then
        cd "$dir"
        git pull
      fi
    fi
  done
  echo ""
  popd &> /dev/null
}

set_prompt ()
{
  LastStatusCode=$?

  # Reset
  Color_Off='\[\e[0m\]'       # Text Reset

  # Regular Colors
  Black='\[\e[0;30m\]'        # Black
  Red='\[\e[0;31m\]'          # Red
  Green='\[\e[0;32m\]'        # Green
  Yellow='\[\e[0;33m\]'       # Yellow
  Blue='\[\e[0;34m\]'         # Blue
  Purple='\[\e[00;35m\]'      # Purple
  Cyan='\[\e[0;36m\]'         # Cyan
  White='\[\e[0;37m\]'        # White

  # Bold
  BBlack='\[\e[1;30m\]'       # Black
  BRed='\[\e[1;31m\]'         # Red
  BGreen='\[\e[1;32m\]'       # Green
  BYellow='\[\e[1;33m\]'      # Yellow
  BBlue='\[\e[1;34m\]'        # Blue
  BPurple='\[\e[1;35m\]'      # Purple
  BCyan='\[\e[1;36m\]'        # Cyan
  BWhite='\[\e[1;37m\]'       # White

  # Underline
  UBlack='\[\e[4;30m\]'       # Black
  URed='\[\e[4;31m\]'         # Red
  UGreen='\[\e[4;32m\]'       # Green
  UYellow='\[\e[4;33m\]'      # Yellow
  UBlue='\[\e[4;34m\]'        # Blue
  UPurple='\[\e[4;35m\]'      # Purple
  UCyan='\[\e[4;36m\]'        # Cyan
  UWhite='\[\e[4;37m\]'       # White

  # Background
  On_Black='\[\e[40m\]'       # Black
  On_Red='\[\e[41m\]'         # Red
  On_Green='\[\e[42m\]'       # Green
  On_Yellow='\[\e[43m\]'      # Yellow
  On_Blue='\[\e[44m\]'        # Blue
  On_Purple='\[\e[45m\]'      # Purple
  On_Cyan='\[\e[46m\]'        # Cyan
  On_White='\[\e[47m\]'       # White

  # High Intensity
  IBlack='\[\e[0;90m\]'       # Black
  IRed='\[\e[0;91m\]'         # Red
  IGreen='\[\e[0;92m\]'       # Green
  IYellow='\[\e[0;93m\]'      # Yellow
  IBlue='\[\e[0;94m\]'        # Blue
  IPurple='\[\e[0;95m\]'      # Purple
  ICyan='\[\e[0;96m\]'        # Cyan
  IWhite='\[\e[0;97m\]'       # White

  # Bold High Intensity
  BIBlack='\[\e[1;90m\]'      # Black
  BIRed='\[\e[1;91m\]'        # Red
  BIGreen='\[\e[1;92m\]'      # Green
  BIYellow='\[\e[1;93m\]'     # Yellow
  BIBlue='\[\e[1;94m\]'       # Blue
  BIPurple='\[\e[1;95m\]'     # Purple
  BICyan='\[\e[1;96m\]'       # Cyan
  BIWhite='\[\e[1;97m\]'      # White

  # High Intensity backgrounds
  On_IBlack='\[\e[0;100m\]'   # Black
  On_IRed='\[\e[0;101m\]'     # Red
  On_IGreen='\[\e[0;102m\]'   # Green
  On_IYellow='\[\e[0;103m\]'  # Yellow
  On_IBlue='\[\e[0;104m\]'    # Blue
  On_IPurple='\[\e[0;105m\]'  # Purple
  On_ICyan='\[\e[0;106m\]'    # Cyan
  On_IWhite='\[\e[0;107m\]'   # White

  Lambda=$'\u03bb'
  ErrorMark='\342\234\227'
  CheckMark='\342\234\223'

  PS1=""
  PS1+="$BPurple${debian_chroot:+($debian_chroot)}\u@\h "
  PS1+="$Color_Off[$BCyan\w$Color_Off]"
  if [[ $LastStatusCode == 0 ]]; then
    PS1+="\n"
    # PS1+="$BCyan$CheckMark "
    PS1+="$BBlue$Lambda"
  else
    PS1+=" $Color_Off(error: $BRed$LastStatusCode$Color_Off)\n"
    # PS1+="$BRed$ErrorMark "
    PS1+="$BRed$Lambda"
  fi
  PS1+="$Color_Off "
}
PROMPT_COMMAND='set_prompt'
pathadd $HOME/bin
pathadd $HOME/bin/ghc/7.8.4/bin
pathadd $HOME/bin/ghc/7.10.1/bin
pathadd $HOME/.cabal/bin
