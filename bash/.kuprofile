# Reset
COLOR_OFF='\[\e[0m\]'       # Text Reset

# Regular Colors
BLACK='\[\e[0;30m\]'        # Black
RED='\[\e[0;31m\]'          # Red
GREEN='\[\e[0;32m\]'        # Green
YELLOW='\[\e[0;33m\]'       # Yellow
BLUE='\[\e[0;34m\]'         # Blue
PURPLE='\[\e[00;35m\]'      # Purple
CYAN='\[\e[0;36m\]'         # Cyan
WHITE='\[\e[0;37m\]'        # White

# Bold
BBLACK='\[\e[1;30m\]'       # Black
BRED='\[\e[1;31m\]'         # Red
BGREEN='\[\e[1;32m\]'       # Green
BYELLOW='\[\e[1;33m\]'      # Yellow
BBLUE='\[\e[1;34m\]'        # Blue
BPURPLE='\[\e[1;35m\]'      # Purple
BCYAN='\[\e[1;36m\]'        # Cyan
BWHITE='\[\e[1;37m\]'       # White

# Underline
UBLACK='\[\e[4;30m\]'       # Black
URED='\[\e[4;31m\]'         # Red
UGREEN='\[\e[4;32m\]'       # Green
UYELLOW='\[\e[4;33m\]'      # Yellow
UBLUE='\[\e[4;34m\]'        # Blue
UPURPLE='\[\e[4;35m\]'      # Purple
UCYAN='\[\e[4;36m\]'        # Cyan
UWHITE='\[\e[4;37m\]'       # White

# Background
ON_BLACK='\[\e[40m\]'       # Black
ON_RED='\[\e[41m\]'         # Red
ON_GREEN='\[\e[42m\]'       # Green
ON_YELLOW='\[\e[43m\]'      # Yellow
ON_BLUE='\[\e[44m\]'        # Blue
ON_PURPLE='\[\e[45m\]'      # Purple
ON_CYAN='\[\e[46m\]'        # Cyan
ON_WHITE='\[\e[47m\]'       # White

# High Intensity
IBLACK='\[\e[0;90m\]'       # Black
IRED='\[\e[0;91m\]'         # Red
IGREEN='\[\e[0;92m\]'       # Green
IYELLOW='\[\e[0;93m\]'      # Yellow
IBLUE='\[\e[0;94m\]'        # Blue
IPURPLE='\[\e[0;95m\]'      # Purple
ICYAN='\[\e[0;96m\]'        # Cyan
IWHITE='\[\e[0;97m\]'       # White

# Bold High Intensity
BIBLACK='\[\e[1;90m\]'      # Black
BIRED='\[\e[1;91m\]'        # Red
BIGREEN='\[\e[1;92m\]'      # Green
BIYELLOW='\[\e[1;93m\]'     # Yellow
BIBLUE='\[\e[1;94m\]'       # Blue
BIPURPLE='\[\e[1;95m\]'     # Purple
BICYAN='\[\e[1;96m\]'       # Cyan
BIWHITE='\[\e[1;97m\]'      # White

# High Intensity backgrounds
ON_IBLACK='\[\e[0;100m\]'   # Black
ON_IRED='\[\e[0;101m\]'     # Red
ON_IGREEN='\[\e[0;102m\]'   # Green
ON_IYELLOW='\[\e[0;103m\]'  # Yellow
ON_IBLUE='\[\e[0;104m\]'    # Blue
ON_IPURPLE='\[\e[0;105m\]'  # Purple
ON_ICYAN='\[\e[0;106m\]'    # Cyan
ON_IWHITE='\[\e[0;107m\]'   # White

# Git colors
GIT_CLEAN=$GREEN
GIT_DIRTY=$IRED

## ls ## {{{
alias ls='ls -hF --color=auto'
alias ll='ls -lh'
alias lr='ls -R'                    # recursive ls
alias la='ll -A'
alias lx='ll -BX'                   # sort by extension
alias lz='ll -rS'                   # sort by size
alias lt='ll -rt'                   # sort by date
alias lm='la | more'
# }}}

pathadd()
{
  if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="${PATH:+"$PATH:"}$1"
  fi
}

# start-sshagent() {
#   eval "$(ssh-agent -s)"
#   ssh-add ~/.ssh/id_rsa
# }

st() {

  usage() {
    echo ""
    echo "Performs 'git status' on all subfolders that are valid git repositories."
    echo ""
    echo "  st [options]"
    echo ""
    echo "Options:"
    echo "   -h, -?  Show this help."
    echo "   -p      Indicates whether to prompt before each action for each git repository."
    echo ""
  }

  prompt=0
  local OPTIND
  while getopts "h?p" opt; do
    case "$opt" in
      p)
        prompt=1
        ;;
      h|\?)
        usage
        return
        ;;
    esac
  done
  shift $((OPTIND-1))

  basedir=`eval pwd`
  basedirLength=${#basedir}

  if ! test -d "$basedir"; then
    echo "Folder does not exist"
    return
  fi

  if test -d "$basedir/.git"; then
    prompt result
    if [ "$result" == y ]; then
      git status
    fi
    return
  fi

  pushd "$basedir" &> /dev/null
  for dir in "$basedir"/*; do
    if test -d "$dir/.git"; then
      echo ""
      echo -e "\e[36m PROCESSING \e[30;48;5;43m ${dir:$basedirLength} \e[0m"
      prompt result
      if [ "$result" == q ]; then
        popd &> /dev/null
        return
      fi
      if [ "$result" == y ]; then
        cd "$dir"
        git status
      fi
    fi
  done
  echo ""
  popd &> /dev/null
}

cl() {

  usage() {
    echo ""
    echo "Performs 'git clean -x -d -f' on all subfolders that are valid git repositories."
    echo ""
    echo "  cl [options]"
    echo ""
    echo "Options:"
    echo "   -h, -?  Show this help."
    echo "   -p      Indicates whether to prompt before each action for each git repository."
    echo ""
  }

  prompt=0
  local OPTIND
  while getopts "h?p" opt; do
    case "$opt" in
      p)
        prompt=1
        ;;
      h|\?)
        usage
        return
        ;;
    esac
  done
  shift $((OPTIND-1))

  basedir=`eval pwd`
  basedirLength=${#basedir}

  if ! test -d "$basedir"; then
    echo "Folder does not exist"
    return
  fi

  if test -d "$basedir/.git"; then
    prompt result
    if [ "$result" == y ]; then
      git clean -x -d -f
    fi
    return
  fi

  pushd "$basedir" &> /dev/null
  for dir in "$basedir"/*; do
    if test -d "$dir/.git"; then
      echo ""
      echo -e "\e[36m PROCESSING \e[30;48;5;43m ${dir:$basedirLength} \e[0m"
      prompt result
      if [ "$result" == q ]; then
        popd &> /dev/null
        return
      fi
      if [ "$result" == y ]; then
        cd "$dir"
        git clean -x -d -f
      fi
    fi
  done
  echo ""
  popd &> /dev/null
}

pull() {

  usage() {
    echo ""
    echo "Performs 'git pull' on all subfolders that are valid git repositories."
    echo ""
    echo "  pull [options]"
    echo ""
    echo "Options:"
    echo "   -h, -?  Show this help."
    echo "   -p      Indicates whether to prompt after each action for each git repository."
    echo ""
  }

  prompt=0
  local OPTIND
  while getopts "h?p" opt; do
    case "$opt" in
      p)
        prompt=1
        ;;
      h|\?)
        usage
        return
        ;;
    esac
  done
  shift $((OPTIND-1))

  basedir=`eval pwd`
  basedirLength=${#basedir}

  if ! test -d "$basedir"; then
    echo "Folder does not exist"
    return
  fi

  if test -d "$basedir/.git"; then
    prompt result
    if [ "$result" == y ]; then
      git pull
    fi
    return
  fi

  pushd "$basedir" &> /dev/null
  for dir in "$basedir"/*; do
    if test -d "$dir/.git"; then
      echo ""
      echo -e "\e[36m PROCESSING \e[30;48;5;43m ${dir:$basedirLength} \e[0m"
      prompt result
      if [ "$result" == q ]; then
        popd &> /dev/null
        return
      fi
      if [ "$result" == y ]; then
        cd "$dir"
        git pull
      fi
    fi
  done
  echo ""
  popd &> /dev/null
}

prompt() {
  local __result=$1
  if [ $prompt -eq 0 ]; then
    local rc='y'
    eval $__result="'$rc'"
    return
  fi
  read -p "Proceed? [yNq] " -n 1 -r
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo ""
    echo -e "\e[36m>yes<\e[0m"
    echo ""
    local rc='y'
    eval $__result="'$rc'"
    return
  fi
  if [[ $REPLY =~ ^[Qq]$ ]]; then
    echo ""
    echo -e "\e[36m>quit<\e[0m"
    echo ""
    local rc='q'
    eval $__result="'$rc'"
    return
  fi
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    echo ""
    echo -e "\e[36m>no<\e[0m"
    echo ""
    local rc='n'
    eval $__result="'$rc'"
    return
  fi
  echo -e "\e[36m>no<\e[0m"
  local rc='n'
  eval $__result="'$rc'"
}

git_prompt() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    return 0
  fi
  if git diff --quiet 2>/dev/null >&2; then
    GIT_BRANCH="$COLOR_OFF ($GIT_CLEAN$(git branch 2>/dev/null | sed -n '/^\*/s/^\* //p')$COLOR_OFF)"
  else
    GIT_BRANCH="$COLOR_OFF ($GIT_DIRTY$(git branch 2>/dev/null | sed -n '/^\*/s/^\* //p')$COLOR_OFF)"
  fi
  echo $GIT_BRANCH
}

kuznero_prompt ()
{
  LastStatusCode=$?
  Lambda=$'\u03bb'
  ErrorMark='\342\234\227'
  CheckMark='\342\234\223'
  PS1=""
  PS1+="$BPURPLE${debian_chroot:+($debian_chroot)}\u@\h "
  PS1+="$COLOR_OFF[$BCYAN\w$COLOR_OFF]$(git_prompt)"
  if [[ $LastStatusCode == 0 ]]; then
    PS1+="\n"
    # PS1+="$BCYAN$CheckMark "
    PS1+="$BBLUE$Lambda"
  else
    PS1+=" $COLOR_OFF(error: $BRED$LastStatusCode$COLOR_OFF)\n"
    # PS1+="$BRED$ErrorMark "
    PS1+="$BRED$Lambda"
  fi
  PS1+="$COLOR_OFF "
}
PROMPT_COMMAND='kuznero_prompt'
pathadd $HOME/bin
pathadd $HOME/.local/bin
